[src/config/index.js]
import dotenv from "dotenv"
dotenv.config()

export const config = {
  jira: {
    baseUrl: process.env.JIRA_BASE_URL,
    username: process.env.JIRA_USERNAME,
    password: process.env.JIRA_PASSWORD,
    projectKey: process.env.JIRA_KEY_PROJECT,
  },
  glpi: {
    baseUrl: process.env.GLPI_BASE_URL,
    userToken: process.env.GLPI_USER_TOKEN,
    appToken: process.env.GLPI_APP_TOKEN,
  },
  statusMapping: {
    jiraToGlpi: {
      "To Do": 1,
      "In Progress": 2,
      Done: 5,
    },
    glpiToJira: {
      1: "To Do",
      2: "In Progress",
      5: "Done",
    },
  },
  dryRun: false,
  // allowDeletion: process.env.ALLOW_DELETION === "true" || false,
  allowDeletion: true,
}

[src/glpi.js]
import axios from "axios"
import { config } from "./config/index.js"
import { log } from "./logger.js"

let sessionToken = null

export async function initGLPISession() {
  try {
    const response = await axios.get(`${config.glpi.baseUrl}/initSession`, {
      headers: {
        Authorization: `user_token ${config.glpi.userToken}`,
        "App-Token": config.glpi.appToken,
      },
    })
    sessionToken = response.data.session_token
    log("GLPI session started")
  } catch (error) {
    log(`GLPI session error: ${error.message}`, "error")
  }
}

export async function killGLPISession() {
  if (!sessionToken) return
  await axios.get(`${config.glpi.baseUrl}/killSession`, {
    headers: {
      "Session-Token": sessionToken,
      "App-Token": config.glpi.appToken,
    },
  })
  log("GLPI session ended")
  sessionToken = null
}

export async function getGLPITickets() {
  try {
    const response = await axios.get(`${config.glpi.baseUrl}/Ticket/`, {
      headers: {
        "Session-Token": sessionToken,
        "App-Token": config.glpi.appToken,
      },
    })
    return response.data
  } catch (error) {
    log(`GLPI get tickets error: ${error.message}`, "error")
    return []
  }
}
export async function createGLPITicket({ name, content, users_id_recipient }) {
  try {
    const response = await axios.post(
      `${config.glpi.baseUrl}/Ticket`,
      {
        input: {
          name,
          content,
          users_id_recipient,
        },
      },
      {
        headers: {
          "Session-Token": sessionToken,
          "App-Token": config.glpi.appToken,
        },
      }
    )

    return response.data
  } catch (error) {
    log(`GLPI create ticket error: ${error.message}`, "error")
    return null
  }
}

export async function deleteGLPITicket(ticketId) {
  if (!config.allowDeletion) {
    log(`‚ö†Ô∏è Deletion disabled - skipping deletion of GLPI ticket ${ticketId}`)
    return false
  }
  try {
    await axios.delete(`${config.glpi.baseUrl}/Ticket/${ticketId}`, {
      headers: {
        "Session-Token": sessionToken,
        "App-Token": config.glpi.appToken,
      },
    })
    return true
  } catch (error) {
    log(`GLPI delete ticket error: ${error.message}`, "error")
    return false
  }
}

export async function updateGLPITicket(
  ticketId,
  { name, content, users_id_recipient }
) {
  try {
    const response = await axios.put(
      `${config.glpi.baseUrl}/Ticket/${ticketId}`,
      {
        input: {
          name,
          content,
          users_id_recipient,
        },
      },
      {
        headers: {
          "Session-Token": sessionToken,
          "App-Token": config.glpi.appToken,
        },
      }
    )
    return response.data
  } catch (error) {
    log(`GLPI update ticket error: ${error.message}`, "error")
    return null
  }
}

[src/index.js]
import { initGLPISession, killGLPISession } from "./glpi.js"
import { syncJiraToGLPI, syncGLPIToJira, syncDeletedItems } from "./sync.js"
import { log } from "./logger.js"

async function main() {
  const mode = process.argv[2] || "both"
  await initGLPISession()

  try {
    if (mode === "cleanup" || mode === "both") await syncDeletedItems()
    if (mode === "jira2glpi" || mode === "both") await syncJiraToGLPI()
    if (mode === "glpi2jira" || mode === "both") await syncGLPIToJira()
  } catch (error) {
    log(`Main error: ${error.message}`, "error")
  } finally {
    await killGLPISession()
  }
}

main()

[src/jira.js]
import axios from "axios"
import { config } from "./config/index.js"
import { log } from "./logger.js"

const auth = Buffer.from(
  `${config.jira.username}:${config.jira.password}`
).toString("base64")
const jiraHeaders = {
  Authorization: `Basic ${auth}`,
  Accept: "application/json",
}

export async function getJiraIssues() {
  try {
    const response = await axios.get(
      `${config.jira.baseUrl}/rest/api/2/search`,
      {
        headers: jiraHeaders,
        params: {
          jql: `project=${config.jira.projectKey}`,
          maxResults: 100,
          fields: "summary,description,updated,reporter",
        },
      }
    )
    return response.data.issues || []
  } catch (error) {
    log(
      `Jira get issues error: ${error.response?.status} ‚Äì ${
        JSON.stringify(error.response?.data) || error.message
      }`,
      "error"
    )
    return []
  }
}

export async function deleteJiraIssue(issueIdOrKey) {
  if (!config.allowDeletion) {
    log(
      `‚ö†Ô∏è Deletion disabled - skipping deletion of Jira issue ${issueIdOrKey}`
    )
    return false
  }
  try {
    await axios.delete(
      `${config.jira.baseUrl}/rest/api/2/issue/${issueIdOrKey}`,
      {
        headers: jiraHeaders,
      }
    )
    return true
  } catch (error) {
    log(`Jira delete issue error: ${error.message}`, "error")
    return false
  }
}

export async function updateJiraIssue(issueIdOrKey, fields) {
  try {
    await axios.put(
      `${config.jira.baseUrl}/rest/api/2/issue/${issueIdOrKey}`,
      { fields },
      { headers: jiraHeaders }
    )
    return true
  } catch (error) {
    log(`Jira update issue error: ${error.message}`, "error")
    return false
  }
}

[src/logger.js]
export function log(message, level = "info") {
  const timestamp = new Date().toISOString()
  const formattedMessage = `[${timestamp}] [${level.toUpperCase()}]: ${message}`
  console.log(formattedMessage)
}

[src/scripts/generateMapping.js]
import axios from "axios"
import fs from "fs"
import dotenv from "dotenv"
dotenv.config()

const { GLPI_API_URL, GLPI_APP_TOKEN, GLPI_USER_TOKEN } = process.env

const mappingFilePath = "./src/utils/mapping.js"

async function getSessionToken() {
  const response = await axios.get(`${GLPI_API_URL}/initSession`, {
    headers: {
      "App-Token": GLPI_APP_TOKEN,
      Authorization: `user_token ${GLPI_USER_TOKEN}`,
    },
  })
  return response.data.session_token
}

async function getUsers(sessionToken) {
  const response = await axios.get(`${GLPI_API_URL}/User`, {
    headers: {
      "Session-Token": sessionToken,
      "App-Token": GLPI_APP_TOKEN,
    },
    params: {
      range: "0-999",
    },
  })

  return response.data
}

function buildUserMap(users) {
  const map = {}
  users.forEach((user) => {
    if (user.name) {
      map[user.name] = user.id
    }
  })
  return map
}

function saveMappingToFile(map) {
  const entries = Object.entries(map)
    .map(([name, id]) => `  "${name}": ${id},`)
    .join("\n")

  const content = `export const userMap = {\n${entries}\n};\n`

  fs.writeFileSync(mappingFilePath, content, "utf8")
  console.log(`mapping.js updated with ${Object.keys(map).length} users.`)
}

async function main() {
  try {
    const token = await getSessionToken()
    const users = await getUsers(token)
    const userMap = buildUserMap(users)
    saveMappingToFile(userMap)
  } catch (err) {
    console.error("Error:", err.message)
  }
}

main()

[src/sync.js]
import { getJiraIssues, deleteJiraIssue, updateJiraIssue } from "./jira.js"
import {
  getGLPITickets,
  createGLPITicket,
  deleteGLPITicket,
  updateGLPITicket,
} from "./glpi.js"
import { config } from "./config/index.js"
import { log } from "./logger.js"
import { userMap } from "./utils/mapping.js"
import axios from "axios"

function safeDate(value) {
  if (!value || typeof value !== "string") return null
  const iso = value.replace(" ", "T")
  const date = new Date(iso)
  return isNaN(date.getTime()) ? null : date
}

const auth = Buffer.from(
  `${config.jira.username}:${config.jira.password}`
).toString("base64")
const jiraHeaders = {
  Authorization: `Basic ${auth}`,
  "Content-Type": "application/json",
  Accept: "application/json",
}

export async function syncJiraToGLPI() {
  const issues = await getJiraIssues()
  const existingTickets = await getGLPITickets()

  const ticketsByJiraId = new Map()
  for (const ticket of existingTickets) {
    const jiraIdMatch = ticket.content?.match(/Jira-ID: ([A-Z]+-\d+)/)
    if (jiraIdMatch) {
      ticketsByJiraId.set(jiraIdMatch[1], ticket)
    }
  }

  for (const issue of issues) {
    const issueKey = issue.key
    const summary = issue.fields.summary
    const descriptionRaw =
      typeof issue.fields.description === "string"
        ? issue.fields.description
        : JSON.stringify(issue.fields.description)

    const existingTicket = ticketsByJiraId.get(issueKey)

    const reporterName = issue.fields.reporter?.displayName || "glpi"
    const userId = userMap[reporterName] || userMap["glpi"]

    const jiraUpdated = safeDate(issue.fields.updated)
    const glpiUpdated = existingTicket
      ? safeDate(existingTicket.date_mod)
      : null

    const isFromGLPI = /GLPI-ID: \d+/.test(descriptionRaw)

    // –õ–æ–≥–∏—Ä—É–µ–º –¥–∞—Ç—ã –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    log(
      `üîç Jira issue ${issueKey} updated: ${
        jiraUpdated?.toISOString() || "?"
      }, GLPI ticket updated: ${glpiUpdated?.toISOString() || "?"}`
    )

    if (!existingTicket) {
      if (isFromGLPI) {
        log(
          `üü° Jira issue ${issueKey} –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –∏–∑ GLPI, –Ω–µ —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π —Ç–∏–∫–µ—Ç`
        )
        continue
      }

      const newContent = `Jira-ID: ${issueKey}\n\n` + descriptionRaw
      const result = await createGLPITicket({
        name: summary,
        content: newContent,
        users_id_recipient: userId,
      })

      if (result) {
        log(`‚úÖ –°–æ–∑–¥–∞–Ω —Ç–∏–∫–µ—Ç –≤ GLPI –¥–ª—è Jira issue ${issueKey}`)
      }
      continue
    }

    if (
      jiraUpdated &&
      (!glpiUpdated || jiraUpdated.getTime() > glpiUpdated.getTime())
    ) {
      const newContent = `Jira-ID: ${issueKey}\n\n` + descriptionRaw
      const updated = await updateGLPITicket(existingTicket.id, {
        name: summary,
        content: newContent,
        users_id_recipient: userId,
      })
      if (updated) {
        log(`üîÑ –û–±–Ω–æ–≤–ª—ë–Ω GLPI —Ç–∏–∫–µ—Ç –¥–ª—è Jira issue ${issueKey}`)
      }
    } else {
      log(
        `üü° GLPI —Ç–∏–∫–µ—Ç –¥–ª—è Jira issue ${issueKey} –Ω–æ–≤–µ–µ, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ`
      )
    }
  }
}

export async function syncGLPIToJira() {
  const tickets = await getGLPITickets()
  log(`–ü–æ–ª—É—á–µ–Ω–æ ${tickets.length} —Ç–∏–∫–µ—Ç–æ–≤ –∏–∑ GLPI`)

  const existingIssues = await getJiraIssues()

  const issuesByGlpiId = new Map()
  for (const issue of existingIssues) {
    const glpiIdMatch = issue.fields.description?.match(/GLPI-ID: (\d+)/)
    if (glpiIdMatch) {
      issuesByGlpiId.set(parseInt(glpiIdMatch[1]), issue)
    }
  }

  for (const ticket of tickets) {
    const ticketId = ticket.id
    const rawSummary =
      (ticket.name && ticket.name.trim()) ||
      (ticket.title && ticket.title.trim()) ||
      `GLPI Ticket ${ticketId}`

    const summary = rawSummary.replace(/^GLPI-\d+:\s*/, "")
    const descriptionRaw = ticket.content || "No description"

    const existingIssue = issuesByGlpiId.get(ticketId)

    const glpiUpdated = safeDate(ticket.date_mod)
    const jiraUpdated = existingIssue
      ? safeDate(existingIssue.fields.updated)
      : null

    const isFromJira = /Jira-ID: [A-Z]+-\d+/.test(descriptionRaw)

    log(
      `üîç GLPI —Ç–∏–∫–µ—Ç ${ticketId} updated: ${
        glpiUpdated?.toISOString() || "?"
      }, Jira issue updated: ${jiraUpdated?.toISOString() || "?"}`
    )

    if (!existingIssue) {
      if (isFromJira) {
        log(
          `üü° GLPI —Ç–∏–∫–µ—Ç ${ticketId} –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –∏–∑ Jira, –Ω–µ —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π issue`
        )
        continue
      }

      const issuePayloadFields = {
        project: { key: config.jira.projectKey },
        summary,
        description: `GLPI-ID: ${ticketId}\n\n` + descriptionRaw,
        issuetype: { name: "Task" },
      }

      try {
        await axios.post(
          `${config.jira.baseUrl}/rest/api/2/issue`,
          { fields: issuePayloadFields },
          { headers: jiraHeaders }
        )
        log(`‚úÖ –°–æ–∑–¥–∞–Ω Jira issue –¥–ª—è GLPI —Ç–∏–∫–µ—Ç–∞ ${ticketId}`)
      } catch (err) {
        log(
          `‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è Jira issue –¥–ª—è GLPI —Ç–∏–∫–µ—Ç–∞ ${ticketId}: ${
            err.response?.status
          } ‚Äì ${JSON.stringify(err.response?.data) || err.message}`,
          "error"
        )
      }
      continue
    }

    if (
      glpiUpdated &&
      (!jiraUpdated || glpiUpdated.getTime() > jiraUpdated.getTime())
    ) {
      const updatedDescription = `GLPI-ID: ${ticketId}\n\n` + descriptionRaw

      const updateFields = {
        summary,
        description: updatedDescription,
      }

      const updated = await updateJiraIssue(existingIssue.key, updateFields)
      if (updated) {
        log(`üîÑ –û–±–Ω–æ–≤–ª—ë–Ω Jira issue –¥–ª—è GLPI —Ç–∏–∫–µ—Ç–∞ ${ticketId}`)
      }
    } else {
      log(
        `üü° Jira issue –¥–ª—è GLPI —Ç–∏–∫–µ—Ç–∞ ${ticketId} –Ω–æ–≤–µ–µ, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ`
      )
    }
  }
}

export async function syncDeletedItems() {
  const jiraIssues = await getJiraIssues()
  const glpiTickets = await getGLPITickets()

  const jiraMap = new Map(jiraIssues.map((issue) => [issue.key, issue]))
  const glpiMap = new Map(glpiTickets.map((ticket) => [ticket.id, ticket]))

  for (const ticket of glpiTickets) {
    const jiraKeyMatch = ticket.content?.match(/Jira-ID: ([A-Z]+-\d+)/)
    if (jiraKeyMatch) {
      const jiraKey = jiraKeyMatch[1]
      if (!jiraMap.has(jiraKey)) {
        log(`üóëÔ∏è Jira issue ${jiraKey} —É–¥–∞–ª–µ–Ω–∞, —É–¥–∞–ª—è–µ–º GLPI —Ç–∏–∫–µ—Ç ${ticket.id}`)
        await deleteGLPITicket(ticket.id)
      }
    }
  }

  for (const issue of jiraIssues) {
    const glpiIdMatch = issue.fields.description?.match(/GLPI-ID: (\d+)/)
    if (glpiIdMatch) {
      const glpiId = parseInt(glpiIdMatch[1])
      if (!glpiMap.has(glpiId)) {
        log(`üóëÔ∏è GLPI —Ç–∏–∫–µ—Ç ${glpiId} —É–¥–∞–ª—ë–Ω, —É–¥–∞–ª—è–µ–º Jira issue ${issue.key}`)
        await deleteJiraIssue(issue.key)
      }
    }
  }
}

[src/utils/mapping.js]
export const userMap = {
  "glpi": 2,
  "post-only": 3,
  "tech": 4,
  "normal": 5,
  "glpi-system": 6,
};

